{% raw %}

<!-- TODO: uniformare {% end .. %} -->

<!-- <style>
pre.example hr {
    border-width: 3px;
    margin-top: 25px;
}
pre.example {
    border-style: solid;
    border-width: 2px;
    border-radius: 2px;
    border-color: #A8E6FF;
    background-color: #ECFAFF;
}
</style> -->


# Scriggo Virtual Machine
{: .no_toc}

The Scriggo virtual machine is a register virtual machine that executes the bytecode generated by the Scriggo compiler from a program, script or template. 


1. TOC
{:toc}

## Registers

The virtual machine has 500 registers divided into the four groups **int**, **float**, **string** and **generic**:

* `i1`, `i2`, ..., `i125`: 125 register of type `int64`
* `f1`, `f2`, ..., `f125`: 125 register of type `float64`
* `s1`, `s2`, ..., `s125`: 125 register of type `string`
* `g1`, `g2`, ..., `g125`: 125 register of type `interface{}`

Local variables with basic type an integer or boolean type are stored in the int registers:
```go
// variabili locali memorizzate nei registri int
var a int
var b uint32
var c rune
var d time.Duration = 5 * time.Second
var e bool // false è memorizzato nei registri con int64(0)
var f MyBool = true // true è memorizzato nei registri con int64(1)
```
Local variables with basic type a float type are stored in the float registers:
```go
// variabili locali memorizzate nei registri float
var a float32
var b float64
var d MyFloat = 3.2
```
Local variables with basic type string are stored in the string registers:
```go
// variabili locali memorizzate nei registri string
var a string
var b MyString = "hello"
```
All other local variables are stored in the generic registers:
```go
// variabili locali memorizzate nei registri generic
var a []int
var b map[string]string
var c interface{}
var d time.Time
var e *S
```

## Instructions

The virtual machine has 120 machine instructions. The most common format for instructions is 32 bits: 

| Opcode     | Operando A  | Operando B  | Operando C |
| ------------- | ------------- | ------------- | ------------- |
| 8 bit      | 8 bit       | 8 bit       | 8 bit      |

For example:

| OpAddInt32 | 2 | 3 | 7 |
| ------- | --- | --- | --- |

sums the values in the registers `i2` and `i3`, as `int32`, and stores the result in the register `i7`.

In the bytecode (the disassembled code), different machine instructions are represented as a single instruction and they can be distinguished from the type of registers on which they operate. For example the machine instructions `OpAddInt64` and `OpAddFloat64` are represented with the single bytecode instruction `Add`:

```go
Add i2 i3 i7 // machine instruction OpAddInt64 2 3 7
Add f5 f1 f3 // machine instruction OpAddFloat64 5 1 3
```

Some instructions have a corresponding negative instruction that treats the second operand as immediate, for example:

| -OpAddInt32 | 2 | 3 | 7 |
| -------- | --- | --- | --- |

sums the value in the register `i2` and the constant value `3`, as `int32`, and stores the result in the register `i7`.

The previous machine instruction `-OpAddInt32` is represented in bytecode as:

```go
Add32 i2 3 i7 // machine instruction -OpAddInt32 2 3 7
```

Note that in this case the second operand is the constant `3` and not the register `i3`.

### Add, Add8, Add16 and Add32

The `Add` instructions sum the operands addressed by `a` and `b` and stores the result in `c`.

The second operand `b` can be an integer constant between -127 and 126:

```go
Syntax:  Add   a b c ; description: c = a + b // for int, int64 and float64
         Add8  a b c ;              c = a + b // for int8
         Add16 a b c ;              c = a + b // for int32
         Add32 a b c ;              c = a + b // for int32 and float32
```

### Addr

The instruction `Addr` takes the address of a slice element or struct pointer field and stores it in `p`. For slices, the slice is addressed by `s` and the index of the element is addressed by `i`. For struct pointers, the struct pointer is addressed by `s` and the field index is addressed by `i`.    

```go
Syntax:  Addr s i p ; description: p = &s[i]
         Addr s i p ;              p = &s.f // where f if the field of s at index i
```

### Alloc

The instruction `Alloc` allocates the memory used by the next instruction or allocates a fixed bytes of memory. If the memory is not limited, `Alloc` is a no-op.

```go
Syntax:  Alloc   ; description: allocates the memory used by the next instruction
         Alloc n ;              allocates n bytes of memory
```

Allocation of memory is necessary only to control the memory usage during the execution. The compiler adds `Alloc` instructions if the `LimitMemorySize` option is used when loading a program, script or template.

### And

The instruction `And` computes the bitwise AND of the operands addressed by `a` and `b` and stores the result in `c`.

```go
Syntax:  And a b c  ; description: c = a & b
```

### AndNot

The instruction `AndNot` computes the AND NOT (bit clear) of the operands addressed by `a` and `b` and stores the result in `c`.

```go
Syntax:  And a b c ; description: c = a &^ b
```

### Append

The instruction `Append` appends `length` values to the slice addressed by `s` and store the resulting slice in `s`. The appended values are the values starting from the register at index `start` and ending to the register at index `start+length-1`. The type of the values register depends on the type of the slice element.

`start` and `length` are integer constant between 1 and 126.

```go
Syntax:  Append start length s ; description: s = append(s, regs[start:start+length]...)
```

### AppendSlice

The instruction `AppendSlice` appends the slice addressed by `s1` to the slice addressed by `s2` and store the resulting slice in `s2`.  

```go
Syntax:  AppendSlice s1 s2 ; description: s2 = append(s2, s1...)
```

### Assert

The instruction `Assert` does the type assertion `x.(T)`. The operand `T` is the index of the `Types` slice of the current running function.

```go
Syntax:  Assert x T v ; description: v, ok = x.(T)
```

If the type assertion successes, it stores the the resulting value into the register `v` (the register type depends on the type `T`), sets the VM field `ok` to `true` and skips the next instruction.

If the type assertion fails, sets the VM field `ok` to `false` and, if the next instruction is a `Panic`, does a run-time panic. TODO: document the `Panic` operand.     

### Bind

TODO: to be removed?

### Break

The instruction `Break` breaks a previous executed `Range` instruction at label `label`.

```go
Syntax:  Break label ; description: break label
```

### Call

The instruction `Call` calls the function addresses by `f`. The operand `f` is an index in the `Functions` slice of the current running function. 

```go
Syntax:  Call f ; description: f(...)
```

The instruction `Call` is 8 bytes long and the last 4 bytes stores... (TODO)

### CallIndirect

TODO

### CallPredefined

TODO

### Cap

The instruction `Cap` gets the cap of the slice addresses by `s` and stores it in `c`. 

```go
Syntax:  Cap s c ; description: c = cap(s)
```

### Case

TODO

### Close

The instruction `Close` closes the channel addressed by `ch`. Closing a closed channel or a `nil` channel causes a run-time panic.  

```go
Syntax:  Close ch ; description: close(ch)
```

### Complex64

The instruction `Complex64` assembles a `complex64` value from the `float32` values addressed by `re` and `im` and stores the resulting complex in `cmpx`.

```go
Syntax:  Complex64 re im cmpx ; description: cmpx = complex(re, im)
```

### Complex128

The instruction `Complex128` assembles a `complex128` value from the `float64` values addressed by `re` and `im` and stores the resulting complex in `cmpx`.

```go
Syntax:  Complex128 re im cmpx ; description: cmpx = complex(re, im)
```

### Continue

The instruction `Continue` begins the next iteration of the previous executed `Range` instruction at label `label`.  
 
```go
Syntax:  Continue label ; description: continue label
```

### Convert, ConvertU

The `Convert` instructions convert the value addressed by `x` to a value of type `T` and stores it in `v`.

`ConvertU` is like `Convert` but converts unsigned integer values.

```go
Syntax:  Convert  x T v ; description: v = T(x)
         ConvertU x T v ;              v = T(x)
```

### Concat

The instruction `Concat` concatenates the string operands addressed by `s1` and `s2` and stores the resulting string in `s3`.

```go
Syntax:  Concat s1 s2 s3 ; description: s3 = s1 + s2
```

### Copy

The instruction `Copy` copies the elements of the slice addressed by `src` to the slice addressed by `dst`. If the operand `n` is not zero, `Copy` stores in the integer register addressed by `n` the number of elements copied .         

```go
Syntax:  Copy src n dst ; description: n = copy(dst, src)
```

### Defer

The instruction `Defer` defers the execution of the function addressed by `f`.        

```go
Syntax:  Defer f ; description: defer f() { ... }
```

TODO: to be completed.

### Delete

The instruction `Delete` removes from the map addressed by `m` the element with key addressed by `k`.

```go
  Syntax:  Delete m k; description: delete(m, k)
```

### Div, Div8, Div16, Div32

The `Div` instructions divide the operands addressed by `a` and `b` and stores the result in `c`.

The second operand `b` can be an integer constant between 1 and 256:

```go
Syntax:  Div   a b c ; description: c = a / b // for int, int64 and float64
         Div8  a b c ;              c = a / b // for int8
         Div16 a b c ;              c = a / b // for int32
         Div32 a b c ;              c = a / b // for int32 and float32
```

### Field

The instruction `Field` gets from the struct pointer referred by `s` the field at the index referred by `i` and stores its value in `v`.

```go
  Syntax:  Field s i v; description: v = s.f // where f is the field of s at index i
```

{% endraw %}