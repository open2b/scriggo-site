{% extends "/layouts/page.html" %}
{% var Page = "faq" %} 
{% macro Title string %}Scriggo Frequently Asked Questions (FAQ){% end %}
{% Content %}

{% raw faq %}

# Frequently Asked Questions

## Origin and nature of the project

### Is Scriggo Open Source?

Yes, it is distributed under the BSD license, the same as Go.

### What is the relationship between Scriggo and Google?

None, apart from the fact that the Go language, with which Scriggo is written and which it interprets, is a Google
project.

### Can I contribute to Scriggo?

Of course, you are welcome.

## Scriggo and Go

### Can you extend the Go language with X functionality?

Scriggo implements exclusively the Go language specification for programs, so if it is not present in the Go
specification it cannot be implemented.

### What versions of Go does Scriggo support?

Scriggo supports the latest two stable versions of Go. Therefore, it currently supports versions 1.16 and 1.17. When
version 1.18 is released, the next stable version of Scriggo will support versions 1.17 and 1.18.

## Safety

### What do you mean that Scriggo is safe?

Scriggo code uses only the standard Go library and does not use the "unsafe" and "syscall" packages.

Code executed by Scriggo, by default, cannot access external code such as packages, functions, variables, constants and
types (apart from the Go builtins) that have not been explicitly provided to it. Therefore, it is possible to restrict
access to the network, file system, environment variables, and the execution of other processes.

Executed code can be interrupted via a context. Therefore, it is not possible to write code that cannot be interrupted.
It is also possible to not allow the use of the "go" statement.

It is not possible instead to limit the memory that an executed code can allocate, there is no safe and efficient way
that can be implemented in Go. Moreover, the new types specified in the executed code allocate memory that is not
released. This is a known limitation of the Go reflect implementation. Specifying the same type does no result,
however, in a new memory allocation.

### How can I run third party code safely?

By running the process in a controlled environment such as a virtual machine.

### Why is a string value not convertible to html type in the templates?

Only untyped string constants are convertible to type _html_ (apart from values of type _html_). The same is true for
the _markdown_, _css_, _js_, and _json_ types. This choice helps to limit cross-site scripting (XSS) vulnerabilities
that the template programmer might encounter unintentionally.

## Versions

### How does versioning work?

Until version 1.0.0 is released, all versions will have the form "0._minor_._patch_". The minor will be increased if
the version introduces an incompatibility with the previous version. Patches are released for the latest minor only.
Once version 1.0.0 is released, patches for the current and previous minor will be released.

### Can it be used in production?

Scriggo is currently already used in production. It is not yet in version 1.0 as there are still some part of the Go
specification to implement, and we want to keep the possibility to make small and limited changes to the templates and API
specifications.

## Performance

### Why is Scriggo so fast and allocates less than other interpreters in Go?

Scriggo implements a virtual machine with registers. The code of the programs in Go and that of the templates is
compiled the first time in bytecode and then executed on the Scriggo virtual machine.

This allows for excellent execution speed and a small memory allocation compared to other interpreters in Go.

### How can Scriggo perform like mainstream languages?

The Go static type checking made it possible to design efficient Scriggo virtual machine instructions even if they have
to call the Go reflect later.

### There is still room for optimization?

The currently generated bytecode is not yet as optimized as we would like. There is therefore still room for
optimization.

## Templates

### Go already has a template system, why another one?

The template system that comes with the standard Go library was designed to be used in simpler situations such as data
formatting and is not, and never pretended to be, a template system with an integrated programming language.
Moreover, it has a non-immediate understanding syntax for those coming from other templating systems like Jinja.

### What is a truthful value in the templates?

We wanted the template language, however Go based, to be easy to use even for non-programmers. A simple instruction
like the following:

``
{% if len(products) == 0 %} There are no products {% end %}
``

brings with it some concepts such as slices, the built-in `len` and the equality operator, which on the whole could 
discourage anyone approaching a template system without having a programming base.

In Scriggo, therefore, the previous code can be written in the following way:

```
{% if not products %} There are no products {% end %}
```

The condition of the _if_ statement can have any type and is _true_ if it is truthful. A _nil_ or empty slice is not
truthful and therefore in the context of the _if_ condition, `len(products) == 0` can be replaced with
`not products`.

`and`,` or` and `not` are three boolean operators, available in templates, which are based on the concept of
truthfulness. For more details you can see the [documentation](/templates/operators#and-or-not) and the
[specifications](/template-spec#truthful-values) of the templates.

### Can you implement X functionality in templates even if it is not present in Go?
If the X functionality is templates specific and does not also concern the Go language, then it can be evaluated. If, on
the other hand, it could also concern the Go language, then it is less likely that it can be implemented as we prefer
to maintain as much consistency as possible with the Go language.

### Why isn't the ?: operator supported in templates?

The same reasons for implementing it in templates would also apply to the Go language, so it should first be added to
the Go specification.

In the context of the templates, consider for example that the following code, not valid in Scriggo,

```
{{ products ? "there are " + sprintf("%d", len(products)) : "no products" }}
```

can be written in Scriggo as follows:

```
{% if products %}there are {{ len(products) }}{% else %}no products{% end %}
```

## Implementation

### How is the compiler written?

Scriggo's compiler is written in Go entirely from scratch and therefore does not rely on any other previously written
compiler. The same compiler is able to compile both Go programs and Scriggo templates with the same code base. This
allows to make fixes, improvements and new features at the same time in the compilation of programs and
templates.

The compiler consists of the parser, a completely handwritten and not self-generated recursive descent parser, the type
checker and the emitter. The final result of the compilation is a series of data structures, one for each Scriggo
function defined in the code and one for each native function called by the Scriggo functions. Templates have an
implicit _main_ function. Each Scriggo function then has the body compiled into bytecode.

### How does the runtime work?

The Scriggo runtime is a virtual machine with registers. Like the compiler, it is written from scratch. Many of the
virtual machine instructions rely on Go reflect functions to operate on type literal values, call native functions,
and implement the _select_ statement.
This allows Scriggo excellent interoperability with Go's native values and functions.

The virtual machine has 4 stacks of registers, one for integers, one for floating-points, one for strings, and one for
all other values. The stacks have a fixed initial size and can then grow when needed.

For more details on registers, and bytecode instructions you can see the [disassembler documentation](/disassembler).

### How are the dependencies in the go.mod file used?

The [github.com/open2b/scriggo](https://pkg.go.dev/github.com/open2b/scriggo) module has dependencies that are used
exclusively by the scriggo command. When using Scriggo embedded in your applications there are no dependencies apart
from the standard Go library.

{% end raw faq %}
